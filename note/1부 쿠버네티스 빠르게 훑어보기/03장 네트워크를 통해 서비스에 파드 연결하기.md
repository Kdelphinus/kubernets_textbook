# 03장 네트워크를 통해 서비스에 파드 연결하기

파드는 쿠버네티스에서 애플리케이션을 구성하는 기본 요소이다. 애플리케이션은 여러 구성 요소로 나뉘기에 파드 역시 여러 요소로 나뉜다. 그렇기에 파드 간의 연결은 필수적이다.

쿠버네티스는 파드 간의 통신을 위해 TCP와 UDP를 지원하지만 파드가 대체될 때마다 IP 주소가 변경되는 문제가 존재한다.
이러한 문제를 해결하기 위해 서비스(Service)에 어드레스 디스커버리(address discovery) 기능을 제공하여 이 문제를 해결하였다.

## 3.1 쿠버네티스 내부의 네트워크 트래픽 라우팅

- 인터넷에서 IP 주소에 기억하기 쉬운 도메인 네임을 붙였듯이, 쿠버네티스는 서비스 이름과 IP 주소를 대응시켜준다.
- 쿠버네티스 클러스터에 전용 DNS 서버가 서비스 이름과 IP 주소를 대응시켜준다.
- 이러한 서비스는 파드와 파드가 가진 네트워크 주소를 추상화한 것이다.
- 따라서 서비스의 주소로 요청을 보내면 쿠버네티스가 서비스와 연결된 파드의 실제 IP 주소로 요청을 연결한다.
- 서비스와 파드의 관계는 레이블 셀렉터를 사용한다.

```yaml
# 간단한 서비스 정의
appVersion: v1  # 서비스는 코어 v1 API를 사용한다
kind: Service
metadata:
  name: sleep-2  # 서비스 이름이 도메인 네임으로 사용된다
spec:  # 서비스 정의에는 셀렉터와 포트의 목록이 포함되어야 한다
  selector:
    app: sleep-2  # app 레이블의 값이 sleep-2인 모든 파드가 대상이다
  ports:
    - port: 80  # 80번 포트를 주시하다가 파드의 80번 포트로 트래픽을 전달한다
```

## 3.2 파드와 파드 간 통신

### ClusterIP

- 클러스터IP는 클러스터 전체에서 통용되는 IP 주소를 생성한다.
- 이 IP 주소는 파드가 어느 노드에 있더라도 접근이 가능하지만 클러스터 내에서만 유효하다.
- 그렇기에 파드 간 통신에서만 사용되며 내부에서는 접근해야 하지만 외부의 접근을 차단해야 하는 분산 시스템의 컴포넌트에 적합하다.
- 기본 설정이기에 생략해도 되지만 의미를 분명히 하기 위해 명시하는 것이 더 낫다.
- 서비스를 포트 포워딩하면 디버깅 용도로 외부 접근을 허용할 수 있지만 임시 형태이다.

```yaml
...
spec:
  ports:
    - port: 80
  selector:
    app: numbers-api
  type: ClusterIP
```

## 3.3 외부 트래픽을 파드로 전달하기

### LoadBalancer

- 로드 밸런서는 외부나 다른 노드에서 들어오는 트래픽을 대상 파드로 전달할 수 있다.
- 로드 밸런서는 클러스터로 트래픽을 전달해 주는 외부 로드 밸런서와 함께 동작하며, 레이블 셀렉터와 일치하는 파드로 트래픽을 전달한다.
- 로드 밸런서의 커버 범위는 클러스터 전체이다. 따라서 어떤 노드에 있는 파드라도 트래픽을 전달받을 수 있다.
- 대상 파드가 요청받은 노드에 있지 않더라도 쿠버네티스가 올바른 노드까지 이 트래픽을 전달한다.

> 서비스의 레이블 셀렉터와 일치하는 파드가 많으면 파드보다 노드를 먼저 선택해야 한다.
> 하지만 이러한 문제는 쿠버네티스가 알아서 해결해주기 때문에 고려할 필요는 없다.

```yaml
...
spec:
  ports:
    - port: 8080  # 서비스가 주시하는 포트
      targetPort: 80  # 트래픽이 전달될 파드의 포트
  selector:
    app: numbers-web
  type: LoadBalancer  # 외부 트래픽도 전달할 수 있는 서비스
```

```shell
> kubectl get svc numbers-web
NAME          TYPE           CLUSTER-IP      EXTERNAL-IP   PORT(S)          AGE
numbers-web   LoadBalancer   10.108.197.20   localhost     8080:32599/TCP   9s
```

- 위 예시는 8080번 포트를 주시하다가 해당 포트로 들어오는 트래픽을 웹 애플리케이션 파드의 80번 포트로 전달한다. 
- 위 서비스에 접근하기 위해서 포트 포워딩 할 필요가 없으며 http://localhost:8080 으로 접근할 수 있다.
- `CLUSTER-IP` 는 클러스터 내부에서 파드 간 통신을 위해 할당되며 `EXTERNAL-IP` 는 외부 IP와 통신에서 사용된다.

> 로드 밸런서 서비스는 실제 IP 주소를 부여받는다. 로컬 환경일 경우 공인 IP 주소를 받지 않지만 AKS 또는 EKS 클러스터에서 실행하면 클라우드에서 제공되는 공인 IP 주소를 부여받는다.
> 이렇게 똑같은 애플리케이션 매니페스트 일지라도 환경에 따라 분산을 구현하는 방식의 차이가 존재한다.
>
> 1. Docker-Desktop
> - 로컬 개발 환경, 단일 컴퓨터에서 동작하는 클러스터
> - 로컬 컴퓨터의 네트워크 스택과 통합되어 로드밸런서 서비스가 로컬 호스트 주소를 사용할 수 있다.
> - 그렇기에 모든 로드밸런서 서비스가 localhost로 외부에 공개되며 여러 개의 로드밸런서 서비스를 사용하려면 포트를 각각 다르게 설정해야 한다.
> 
> 2. K3s
> - 별도의 라우팅 테이블을 설정하는 방식으로 로드밸런서 서비스 구현
> - 각각의 로드밸런서 서비스는 호스트 컴퓨터(여기선 가상 머신)의 IP 주소로 외부에 공개
> - 따라서 localhost 또는 IP 주소(로컬 네트워크에서 접근도 가능)로 로드밸런서 서비스에 접근 가능
> - 역시 여러 개의 로드밸런서 사용을 위해선 포트를 다르게 설정해야 한다.
> 
> 3. AKS, EKS 같은 클라우드 환경
> - 클라우드 환경의 쿠버네티스는 고가용성을 확보한 다중 노드 클러스터다.
> - 이러한 서비스에서 로드밸런서 서비스를 배포하면 실제 로드밸런서가 생성된다. 이렇게 생성된 로드밸런서가 외부에서 들어오는 트래픽을 노드로 전달하고 쿠버네티스가 다시 파드로 전달한다.
> - 그렇기에 로드밸런서 서비스 IP 주소는 각각 다르며 공인 IP 주소이기에 인터넷에서 접근할 수 있다.

### NodePort

- 클러스터를 구성하는 모든 노드가 이 서비스에 지정된 포트를 주시하며 들어온 트래픽을 대상 파드의 대상 포트로 전달한다.
- 외부 로드 밸런서가 필요 없다.
- 어떤 노드가 요청을 받더라도 대상 파드가 있는 곳으로 트래픽이 전달된다.

#### 단점

- 서비스에 설정된 포트가 모든 노드에서 개방되어 있어야 하기 때문에 로드 밸런서 만큼 유연하지 않다.
- 다중 노드 클러스터에서 로드밸런싱 효과를 얻을 수 없다.
- K3s나 도커 데스크톱에서는 잘 동작하지만, Kind에서는 그렇지 못하다.
- 클러스터 환경에 따라 동일하게 동작하지 않는다.

```yaml
...
spec:
  ports:
    - port: 8080  # 다른 파드가 서비스에 접근하기 위해 사용하는 포트
      targetPort: 80  # 대상 파드에 트래픽을 전달하는 포트
      nodePort: 30080  # 서비스가 외부에 공개되는 포트
  selector:
    app: numbers-web
  type: NodePort  # 노드의 IP 주소를 통해 접근 가능한 서비스
```

## 3.4 쿠버네티스 클러스터 외부로 트래픽 전달하기

- 데이터베이스 같은 스토리지 컴포넌트 등 쿠버네티스 외부에서 동작하는 소프트웨어가 존재한다.
- 특히 클라우드 환경에선 매니지드 데이터베이스 서비스를 활용하는 경우가 대부분이다.
- 데이터 센터에 배포한 시스템을 쿠버네티스와 통합되지 않은 시스템과 연동할 필요가 있을 수도 있다.
- 애플리케이션 구조와 무관하게 클러스터 외부를 가리키는 도메인 네임 해소에도 쿠버네티스 서비스 리소스를 활용할 수 있다.

### ExternalName

- 어떤 도메인 네임에 대한 별명이라고 생각하면 쉽다.
- 애플리케이션 파드에서 로컬 네임을 사용하고, 쿠버네티스 DNS 서버에 이 로컬 네임을 조회하면 외부 도메인으로 해소해 주는 방식이다.
- 파드는 클러스터 외부의 컴포넌트와 통신하지만, 이를 알지 못한다. 왜냐하면 파드에서 사용하는 도메인 네임이 로컬 도메인 네임이기 때문이다.

```yaml
apiVersion: v1
kind: service
metadata:
  name: numbers-api
spec:
  type: ExternalName
  externalName: raw.githubusercontent.com  # 로컬 도메인 네임을 해소할 외부 도메인
```

- 익스터널네임 서비스는 DNS 표준 기능 중 하나인 캐노니컬 네임(Canonical NAME, CNAME)을 사용하여 구현되었다.
- 웹 애플리케이션 파드가 도메인 네임 `numbers-api` 를 조회하면 쿠버네티스 DNS 서버가 이 CNAME(raw.githubusercontent.com)을 반환한다.
- 애플리케이션이 사용하는 주소가 가리키는 대상을 치환해 줄 뿐 요청의 내용 자체를 바꾸어 주지는 못한다.
  - 이는 데이터베이스처럼 TCP 프로토콜을 쓰는 컴포넌트라면 문제가 없다.
  - 하지만 HTTP 요청의 헤더에는 대상 호스트명이 들어간다. 그리고 이 헤더의 호스트명이 익스터널네임 서비스의 응답과 다르다면 HTTP 요청이 실패한다.

### Headless Service

- HTTP 헤더 문제를 해결하지는 못하지만 익스터널네임 서비스와 비슷하게 도메인 네임 대신 IP 주소를 대체해주는 방법
- 클러스터IP 형태로 정의되지만 레이블 셀렉터가 없기 때문에 대상 파드가 없다.
- 그 대신 자신이 제공해야 할 IP 주소의 목록이 담긴 엔드포인트(endpoint) 리소스와 함께 배포된다.

```yaml
apiVersion: v1
kind: Service
metadata:
  name: numbers-api
spec:
  type: ClusterIP  # selector 필드가 없으므로 헤드리스 서비스가 됨
  ports:
    - port: 80

---

apiVersion: v1
kind: Endpoints
metadata:
  name: numbers-api
subsets:
  - address:  # 정적 IP 주소 목록
    - ip: 102.168.123.234
  ports:
    - ports: 80  # 그리고 각 IP 주소에서 주시할 포트
```

- 예시에서 사용된 IP 주소는 실제 주소가 아니지만, 쿠버네티스는 정의에 포함된 주소가 실재하는지 확인하지 않기에 정상적으로 배포된다.

## 3.5 쿠버네티스 서비스의 해소 과정

### DNS 조회 결과가 왜 엔드포인트의 IP 주소가 아니라 클러스터IP의 주소를 가리킬까

- 클러스터IP는 네트워크상에 실재하지 않는 가상 IP 주소다.
- 클라이언트가 항상 최신 상태의 엔드포인트 목록을 적용받는 과정은 다음과 같다.

1. 파드는 각 노드마다 동작하는 네트워크 프록시를 경유하여 네트워크에 접근한다.
2. 이 프록시는 패킷 필터링을 적용하여 가상 IP 주소를 실제 엔드포인트로 연결한다.
3. 서비스 리소스는 삭제될 때까지 IP 주소가 바뀌지 않으며 애플리케이션의 다른 부분과 무관하게 오래 지속될 수 있다.
4. 서비스에도 컨트롤러가 있어 파드가 변경될 때마다 엔드포인트의 목록을 최신으로 업데이트한다.

- 위 과정에서 알 수 있듯이 엔드포인트가 가리키는 IP 주소는 계속해서 변화한다.
- 그에 반해 정적 가상 IP 주소는 파드가 아무리 여러 번 교체되어도 그대로 유지된다.
- 그렇기에 고정되는 클러스터IP의 주소를 반환한다.

### 도메인 네임은 왜 `numbers-api.default.svc.cluster.local` 과 같은 형태일까

- 위 질문에 대해 알기 위해선 먼저 쿠버네티스의 네임스페이스(namespace)를 먼저 살펴봐야 한다.

> #### Namespace
> 
> - 쉽게 말해 다른 리소스를 하나로 묶기 위한 리소스
> - 쿠버네티스 클러스터를 논리적 파티션으로 나누는 역할을 한다.
> - default 네임스페이스는 항상 존재하고 다른 네임스페이스를 추가할 수 있다.
> - DNS 서버나 쿠버네티스 API 같은 쿠버네티스 내장 컴포넌트는 `kube-system` 네임스페이스에 속한 파드에서 동작한다.

- 서비스 이름은 로컬 도메인 네임으로 사용되는데, 로컬 도메인 네임은 네임스페이스를 포함하는 완전한 도메인 네임의 별명이다.
- 그렇기에 질문에서 나온 도메인 네임은 `{서비스 이름}.{네임스페이스}.svc.cluster.local` 형태라고 할 수 있다.
- 쿠버네티스의 DNS 서버인 `kube-dns` 서비스의 도메인 네임은 `kube-dns.kube-system.svc.cluster.local` 임을 통해 차이를 알 수 있다.
