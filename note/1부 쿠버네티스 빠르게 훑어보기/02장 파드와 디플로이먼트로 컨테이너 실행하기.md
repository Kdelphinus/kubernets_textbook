# 02장 파드와 디플로이먼트로 컨테이너 실행하기

## 2.1 쿠버네티스는 어떻게 컨테이너를 실행하고 관리하는가

### 기본 개념

- 파드(pod): 쿠버네티스가 하나 또는 그 이상의 컨테이너를 관리하는 데 사용하는 단위
- 디플로이먼트(deployment): 파드의 관리를 담당

### 파드

- 컨테이너를 감싸는 또 다른 가상 환경
- 클러스터를 이루는 노드 중 하나에서 실행
- 이떄 쿠버네티스가 직접 컨테이너를 실행하지 않는다. 이는 해당 노드에 설치된 컨테이너 런타임(대체로 도커)에 맡기는 형태
    - 이는 `describe` 명령어 출력 중 컨테이너 식별자를 통해 확인할 수 있다.
- 파드는 노드에 배정되며 노드는 파드를 관리하고 파드 내에 포함된 컨테이너를 실행하는 책임을 가진다.

> #### kubectl
>
> 쿠버네티스 API를 사용하여 쿠버네티스 클러스터의 컨트롤 플레인과 통신하기 위한 커맨드라인 툴

> #### 컨테이너 런타임 인터페이스(Container Runtime Interface, CRI)
>
> 컨테이너 런타임과 연동되는 공통 API로 컨테이너 생성, 삭제, 정보 확인 기능이 제공된다.

### 컨테이너를 파드로 추상화하는 이유

- 컨테이너 런타임이 도커일 때, `docker container` 명령어로 컨테이너를 삭제해도 파드 안에 컨테이너가 존재한다. 이는 파드 내부에 컨테이너가 삭제되자마자 쿠버네티스가 즉각적으로 컨테이너를 생성하여 복원했기 때문이다.
    - 그렇기 때문에 컨테이너 식별자는 이전과 다름을 확인할 수 있다.
- 이렇게 빠른 문제 해결이 가능한 이유가 바로 컨테이너를 파드로 추상화했기 때문이다.
- 위 예시에선 컨테이너의 문제가 생겨도 이는 일시적인 문제이며 파드는 정상 동작 중이기에 새로운 컨테이너를 추가하여 복원하면 된다.
- 이것이 쿠버네티스에서 제공하는 자기수복성의 첫 번째 단계이다. 파드 위로 더 쌓일 추상화를 통해 애플리케이션은 더 큰 복원력을 가질 수 있다.

## 2.2 컨트롤러 객체와 함께 파드 실행하기

### 컨트롤러(controller) 객체

- 노드가 망가지면 파드가 유실된다. 이는 파드의 복원력만으로 해결할 수 없다. 이를 위해 컨트롤러 객체가 존재한다.
- 컨트롤러 객체는 다른 리소스를 관리하는 쿠버네티스 리소스이다.
- 쿠버네티스 API와 연동하여 시스템의 현재 상태를 감시하다가 '이상적 상태'와 차이가 생기면 필요에 따라 차이를 바로 잡는다.
- 대표적으로 디플로이먼트가 컨트롤러 객체이다.

### 디플로이먼트(deployment)

- 디플로이먼트를 실행하면 파드를 자동으로 생성해준다.
    - 쿠버네티스 API로 리소스를 확인하고 필요한 리소스를 생성하는 과정을 통해 파드 생성
- 디플로이먼트가 관리해야 할 리소스를 확인하기 위해 레이블을 사용한다.
    - 모든 쿠버네티스 리소스는 간단한 키-값 쌍 형태의 레이블을 가지며, 원하는 데이터를 담는 데 사용할 수 있다.
    - 이 레이블은 정보 표시나 **리소스 간의 느슨한 연결** 을 만드는데 사용된다.
- 대개는 디플로이먼트와 같은 고수준 리소스를 이용하여 파드 관리를 맡긴다. 즉 직접적으로 파드를 생성하는 일은 극히 드물다.

### 컨트롤러가 자신이 관리할 리소스 파악하는 방법

- 디플로이먼트가 생성한 파드는 `app={value}` 레이블이 부여되어있지만 직접 생성한 파드는 `release={value}` 레이블이 부여되어있다.
- 컨트롤러의 정의에는 레이블 셀렉터가 포함되어 있기에 언제라도 쿠버네티스 API를 통해 자신이 관장하는 리소스를 찾아볼 수 있다.
- 그렇기에 컨트롤러는 레이블 셀렉터를 통해 자신이 관리하는 파드를 식별하고 관리한다.
    - 만약 레이블을 직접 바꾼다면 디플로이먼트는 자신이 관리할 레이블을 가질 파드를 잃어버린 것임으로 다시 파드를 생성한다.
    - 만약 레이블을 생성된 다른 파드의 레이블을 디플로이먼트가 설정한 레이블로 바꾼다면 1개(정의된 개수)의 파드만 남기고 삭제한다.
    - 이런 방식으로 레이블을 변경하여 새로운 파드가 생성되게 한 뒤 디버깅하거나 수정한 파드의 레이블을 바꿔 배포할 수도 있다.

## 2.3 애플리케이션 매니페스트에 배포 정의하기

### 매니페스트

- JSON 과 YAML 형식을 지원한다.
- 쿠버네티스 API 정식 스크립트 형식은 JSON 이지만, 가독성이 뛰어나고 파일 하나에 더 많은 리소스를 정의할 수 있는 (무엇보다 주석이 가능한) YAML 형식을 많이 쓴다.
- 파드의 기본 형식(YAML)
```yaml
apiVersion: v1
kind: Pod
metadata:
  name: hello-kiamol-3
spec:
  containers:
    - name: web
      image: kiamol/ch02-hello-kiamol
```
- 쿠버네티스의 API 버전과 정의하려는 리소스 유형으로 시작
- 리소스의 메타데이터에는 이름(필수 요소)과 레이블(비필수 요소)이 있다.
- 스펙은 리소스의 실제 정의 내용이다. 파드의 경우 실행할 컨테이너를 정의해야 하며 컨테이너는 이름과 이미지로 정의된다.
- 매니페스트는 최종 결과를 제시하고 과정은 따지지 않는 선언적 방식이다.
    - 앞선 실습에서 사용한 `kubectl run` 은 명령형 방식이다.
    - 그렇기에 같은 리소스를 또 요청하면 수정할 것이 없다고 출력한다.
- 디플로이먼트의 기본 형식
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello-kiamol-4
spec:
  selector:
    matchLabels:
      app: hello-kiamol-4
  template:
    metadata:
      labels:
        app: hello-kiamol-4
    spec:
      containers:
        - name: web
          image: kiamol/ch02-hello-kiamol
```
- 관리 대상을 결정하는 레이블 셀럭터 정의, 여기선 app 레이블 사용
- 템플릿은 디플로이먼트가 파드를 만들 때 사용한다.
    - `meatadata` : 디플로이먼트 정의 속 파드의 정의엔 이름이 없지만 레이블 셀렉터와 일치하는 레이블을 지정해야 한다.
    - `spec` : 파드의 정의에는 컨테이너 이름과 이미지 이름을 지정한다.

## 2.4 파드에서 실행 중인 애플리케이션에 접근하기

### 접근 및 로깅

- `kubectl exec -it {pod name} sh` : 현재 터미널 세션에 파드 속 컨테이너 쉘 실행
- `kubectl log {pod name}` : 컨테이너 로그 출력하기
    - 추후엔 `{pod name}` 에는 namespace나 리소스 종류를 정의해줘야 할 수도 있음
- 디플로이먼트가 배포한 파드 이름을 모를 때
    - `kubectl exec {deploy name} -- sh -c 'wget -O - http://localhost > /dev/null` : 디플로이먼트가 만든 파드 안 웹 애플리케이션 실행
    - `kubectl logs --tail=1 -l app={app label value}` : 로그 확인

### 파일 시스템 접근

- `kubectl cp {pod name}:{pod 내부 path} {local path}` : 파드 속 파일을 로컬에 복사
- 반대도 가능

## 2.5 쿠버네티스의 리소스 관리 이해하기

### 삭제한 리소스가 되살아날 때

- 컨트롤러 객체가 만든 리소스는 컨트롤러가 책임을 진다. 그렇기 때문에 리소스를 직접 삭제하면 컨트롤러 객체가 다시 생성시킨다.
- 예를 들어 디플로이먼트가 생성한 파드를 직접 삭제하면 디플로이먼트가 자신의 책임인 파드를 다시 생성한다.
- 그렇기 때문에 컨트롤러 객체를 꼭 삭제해야 한다.